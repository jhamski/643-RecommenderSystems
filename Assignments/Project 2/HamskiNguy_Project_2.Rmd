---
title: 'Project #2 - Recommender Systems'
author: "J. Hamski, V. Nguy"
date: "June 22, 2016"
output: html_document
runtime: shiny
---

The goal of this assignment is for you to try out different ways of implementing and configuring a recommender, and to evaluate your different approaches.

For project 2, you’re asked to take some recommendation data (such as your toy movie dataset, Movielens, or another Dataset of your choosing), and implement at least two different recommendation algorithms on the data.  For example, content-based, user-user CF, and/or item-item CF.  You should evaluate different approaches, using different algorithms, normalization techniques, similarity methods, neighborhood sizes, etc.  You don’t need to be exhaustive—these are just some suggested possibilities.  You may use whatever third party libraries you want.  Please provide at least one graph, and a textual summary of your evaluation.


```{r, warning=FALSE, message=FALSE, cache=TRUE}
require(dplyr)
require(ggplot2)
require(tidyr)
require(knitr)
require(Matrix)
require(recommenderlab)
require(shiny)
```

# Description
[Last.fm](http://www.lastfm.com), a web application which allows users to track what music they play on their computer or mobile devices, released a listener dataset from 2006. [Dataset information](http://files.grouplens.org/datasets/hetrec2011/hetrec2011-lastfm-readme.txt).  


```{r, cache=TRUE}
#use a file from the other dataset
user.artists.pairwise <- readRDS("user_artists_pairwise.RDS")
```

The Last.fm dataset contains an array of artist tags. These are voluntarily contributed by arists and are most frequently genres like 'rock' or 'country'. Here, we read in the user-supplied tags dataset and a key that gives the actual tag names ('tagValues').
```{r, cache=TRUE}
user.taggedartist <- read.delim('hetrec2011-lastfm-2k/user_taggedartists.dat', sep="\t")
tags <- read.delim('hetrec2011-lastfm-2k/tags.dat', sep="\t")
```


# Exploring the Dataset

The tag dataset includes 186,479 tags. It inlcudes the user id, and timestamp of the tag, the artist tagged, and the tag given. 
```{r, cache=TRUE}
user.taggedartist <- inner_join(user.taggedartist, tags, by = "tagID")
length(user.taggedartist$tagValue)
str(user.taggedartist)
```

Here we create a column of actual artist names in addition to numeric codes. 
```{r, cache=TRUE}
user.artist.key <- user.artists.pairwise %>%
  unique() %>%
  select(artistID, name)

user.taggedartist <- left_join(user.taggedartist, user.artist.key, by = "artistID")
```

In order to make this dataset more managable, we limit it to tags which have at least 80 occurances. Because the tags are user-derived, there is an extremely long tail of less than useful tags (e.g. "jimsfavoriteband"). The top 80 tags includes many genre tags we would expect to be useful (e.g. "rock", "dance") and leaves us with a dataset of 138,243 total tags.  
```{r, cache=TRUE}
tag.count.top500 <- user.taggedartist %>% 
  count(tagValue) %>% 
  arrange(desc(n)) %>%
  filter(n >= 1917)

user.taggedartist <- user.taggedartist %>%
  filter(tagValue %in% tag.count.top500$tagValue)

length(user.taggedartist$tagValue)
tag.count.top500[1:15,]

str(user.taggedartist)
```


Let's check the tags for a few artists to make sure they make sense. Nick Cave and the Bad Seeds is a genre-diverse band and have 44 user-defined tags.   
```{r, fig.width=3, cache=TRUE}
NickCaveBadSeeds.tags <- user.taggedartist %>%
  filter(name == "Nick Cave and the Bad Seeds") %>%
  select(name, tagValue) %>%
  count(tagValue) %>%
  arrange(desc(n))
kable(NickCaveBadSeeds.tags)
```

We can also view a more genre-specific artist like Ludacris, a rapper who has 22 tags in the dataset. Luudacris's tags also exemplify another issue with using tag for recommendations - poor data quality. Both "hip hop" and "hip-hop" are separate tags, which if added together, would overtake "rap" as the most popular tag. Ideally, before using tags as a recommendation data source we would perform text modification methods such as stemming and removing select characters - however this will have to wait for another project.  

```{r, cache=TRUE}
Ludacris.tags <- user.taggedartist %>%
  filter(name == "Ludacris") %>%
  select(name, tagValue) %>%
  count(tagValue) %>%
  arrange(desc(n))
kable(Ludacris.tags)
```

Despite the example shown, raw number of tags should not be interpreted as the artist's genre-diversity. The willingness of one artist's fanbase to use and add tags may influence the tags more than a feature related to the artist's music itself.  


# Recommender #1 - Return Artist Based on Tag Frequency

This first recommendation system recommends artists to the user based on tag-frequency. This is classified as a content-based filtering method, utilitizing crowd-sourced data (as opposed to curated data or profile-derived data). 

```{r}
#artist.tags <- user.taggedartist %>% group_by(name, tagValue) %>% tally()

tags.by.artist <- user.taggedartist %>% group_by(tagValue, name) %>% tally()

rock.test <- tags.by.artist %>%
  filter(tagValue == "rock") %>%
  arrange(desc(n)) %>%
  select(name)

# make sure this output makes sense
rock.test$name[1:10]
```

Here, we use Shiny to simulate a 'cold start' recommendation using artist tags. A new user, for which we have no listening history (therefore we can't use collaborative filtering) comes to our recommender interface and is asked to select a few tags that reflect their taste in music.   
```{r, echo=TRUE}
tag.options <- tags.by.artist$tagValue %>%
  unique() %>%
  as.character()


shinyApp(
  
  ui = fluidPage(
    fluidRow(
    selectInput('tag', 'Begin typing a tag (example: rock)', tag.options, multiple=TRUE, selectize=TRUE, selected="rock"),
    fluidRow(
      verbatimTextOutput("artist.list"))
  )
  ),
  server = function(input, output) {

    output$artist.list <- renderPrint({

        data <- tags.by.artist %>%
          filter(tagValue %in% unlist(input$tag)) %>%
          select(name, n) %>%
          ungroup() %>%
          arrange(desc(n)) 
        data
    })
  },
  
  options = list(height = 500)
)
```

This recommendation engine is undesireable because it just reflects the most popular artists. If we add a less popular tag to our list (e.g. rock + pop + trance), it doesn't influence the results.  


# Recommender #2 - Return Artist Based on Tag Density

This first recommendation system recommends artists to the user based on tag-frequency. 
```{r}

```

