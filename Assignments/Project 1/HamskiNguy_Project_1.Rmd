---
title: "Project 1 - Basic Recommender System"
author: "J. Hamski, V. Nguy"
date: "June 12, 2016"
output: pdf_document
---

```{r, warning = FALSE, error = FALSE, message=FALSE}
library(recommenderlab)
library(Matrix)
library(dplyr)
library(tidyr)
library(ggplot2)

options(scipen=999)
```

# Description
Using Last.fm data we will build a simple recommender system that will recommend music to the users. We will be building this recommender system using collaborative filtering. The system will use both a Item-based collaborative filter and User-based collaborative filtering (seperately) to recommend music to the users.

[Dataset information](http://files.grouplens.org/datasets/hetrec2011/hetrec2011-lastfm-readme.txt)

# Dataset
[Last.FM](http://grouplens.org/datasets/hetrec-2011/) data from grouplens.org. The dataset we are interested in is the 'user_artists.dat' data file. This file contains the artists listened by each user. It also provides a listening count for each [user, artist] pair.

```{r}
user.artists.pairwise <- read.delim('hetrec2011-lastfm-2k/user_artists.dat', sep="\t")

artists <- read.delim('hetrec2011-lastfm-2k/artists.dat', sep="\t") %>%
  select(id, name)

head(user.artists.pairwise)
```

## Converting from Artist IDs to Artist Names for easier interpretation
```{r}
colnames(artists) <- c("artistID", "name")
#note: one duplicate artist
#artists$name[duplicated(artists$name)==TRUE]

user.artists.pairwise <- inner_join(user.artists.pairwise, artists, by="artistID")

user.artists.pairwise <- select(user.artists.pairwise, -artistID)

user.artists.pairwise[16060,]$name <- NA

ggplot(user.artists.pairwise, aes(x = weight)) + geom_density() + theme_bw() + scale_x_log10()
```

#Data Preparation
Using the TidyR library. The pairwise data was converted into a sparse matrix.

```{r}
user.artists.matrix <- user.artists.pairwise %>%
  #NOTE - Currently changed to larger number. Its taking too long to run on my machine.
  filter(weight > 5000) %>% #filter artists with less than 900 listens
  spread(key = name, value = weight) %>%
  as.matrix()

user.artists <- user.artists.matrix[,-1]
dim(user.artists)
```



For development, work with a smaller matrix. Set eval = FALSE for final rendering. 
```{r, eval=TRUE}
#note - perhaps this should select randomly instead of the first 1000 rows / 500 columns?
#user.artists <- user.artists[1:200, 1:500]

user.artists.colSums <- colSums(user.artists, na.rm=TRUE)

summary(user.artists.colSums)
```


# Calculating Similarity using the 'recommenderlab' package
```{r}
#note this is takes a few minutes to compute
user.artists.RRM <- new("realRatingMatrix", data = as(user.artists, "CsparseMatrix"))

reclab.similarity.user <- similarity(user.artists.RRM, method = "cosine", which = "users")
reclab.similarity.item <- similarity(user.artists.RRM, method = "cosine", which = "items")

reclab.sim.item.matrix <- as.matrix(reclab.similarity.item)
```

```{r}
image(as.matrix(reclab.similarity.user))
image(reclab.sim.item.matrix)
```

```{r, eval=FALSE}
#Old-school hiphop band A Tribe Called Quest's similar listens
ATribeCalledQuest.sim.row <- reclab.sim.item.matrix["A Tribe Called Quest",]

#Was not running before. I set the eval property to false for the time being.
ATribeCalledQuest.similar.listens <- ATribeCalledQuest.sim.row[complete.cases(AgentOrange.sim.row)]

#Several similar artists - De La Soul, Beck, Sade are in the same genre
sort(ATribeCalledQuest.similar.listens, decreasing = TRUE)[1:20]
```


# Calculating Similiarity using built-in Matrix Algebra Functions

```{r, eval=FALSE}

cosineDist <- function(x){
  as.dist(1 - x%*%t(x)/(sqrt(rowSums(x^2) %*% t(rowSums(x^2))))) 
}

cosineDist(user.artists)

image(as.matrix(user.artists))
```



# Calculate Similarity using our own Cosine Distance Algorithm 
```{r}
euc_distance <- function(x) {
  return (sqrt(sum(x^2,na.rm=TRUE)))
}

cos_sim_matrix <- function(x) {
  # initialize similarity matrix
  m <- matrix(NA, nrow=ncol(x),ncol=ncol(x),dimnames=list(colnames(x),colnames(x)))
  similarity <- as.data.frame(m)
  
  for(i in 1:ncol(x)) {
    for(j in i:ncol(x)) {
      #Take only the columns in which both users ranked the item
      co_rate_1 <- x[which(x[,i] & x[,j]),i]
      co_rate_2 <- x[which(x[,i] & x[,j]),j]  
      #Calculate the Cosine Similarity
      similarity[i,j]= sum(co_rate_1*co_rate_2) / (euc_distance(x[,i]) * euc_distance(x[,j]))
      #Replicate results for the 'other half' of the matrix
      similarity[j,i]=similarity[i,j]        
    }
  }
  return(similarity)
}
```

Test case to validate results. Using toy dataset from meetup. Set to false before final rendering.
```{r, eval=TRUE}
movie <- read.csv('UBCF.csv', header = TRUE, stringsAsFactors = FALSE)
rownames(movie) <- movie[,1]
movie <- movie[,-1]

#Results should match Item-Item CF tab
cos_sim_matrix(movie)

#Results should match User-User CF tab
cos_sim_matrix(t(movie))
```

```{r}
#Results should match Item-Item CF tab
custom.similarity.item <- cos_sim_matrix(user.artists)

#Results should match User-User CF tab
#custom.similarity.user <- cos_sim_matrix(t(user.artists))
```

```{r}
test <- custom.similarity.item["Nine Inch Nails",]
test2 <- as.matrix(t(test))

test2<- test2[!(apply(test2, 1, function(y) any(y == 0))),]

movie <- movie[,-1]

test2 <- test2[,1]==0
View(test2)
View(t(test))

```
